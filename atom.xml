<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>学与思</title>
  
  <subtitle>AE的个人博客</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-02-02T03:18:53.925Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>AE</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/02/ET%E8%A1%8C%E4%B8%BA%E6%A0%91%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2023/02/02/ET%E8%A1%8C%E4%B8%BA%E6%A0%91%E8%AE%BE%E8%AE%A1/</id>
    <published>2023-02-02T03:19:11.112Z</published>
    <updated>2023-02-02T03:18:53.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲:"></a>大纲:</h1><ol><li><p>数据结构设计.</p></li><li><p>逻辑层设计 (+节点热更问题)</p></li><li><p>编辑器设计.</p></li><li><p>编辑器布局和操作说明</p></li><li><p>行为树运行的Debug. (等待施工)</p></li></ol><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h1><p>编辑器数据和运行时数据严格分离. 考虑到客户端和服务器两用.<br>客户端数据存储方式使用ScriptableObject,服务器使用Json.<br>目的是为了方便客户端的行为树节点直接引用一些特定的预制体(比如特效,音效)</p><p>运行时数据 (伪代码):</p><p>最基本的节点数据只有一个简单的Id,这个编辑器创建节点时自动生成,只读不可更改.(具有树内唯一性)</p><p>组合节点用来标明行为树的运行逻辑,一般常用的有Seq,Select,Parallel,Random.<br>(序列,选择,并发,随机)</p><p>序列节点Sequence:<br>所有子节点运行成功,它返回成功,有一个返回false,它返回false</p><p>选择节点Select: 有一个子节点返回成功,它返回成功,否则返回false</p><p>并发节点Parallel :<br>N个子节点返回成功,它返回成功.并且子节点之间的逻辑同时执行.一般在任务编辑,流程编辑,AI编辑中常用.</p><p>随机节点Random:<br>随机选择一个子节点,一般是AI中使用,但考虑到ET并不推荐使用行为树作为AI的编辑器.所以这个后续就不做了.</p><p>根节点一般代表着这棵树针对哪一种实体运行,比如有针对游戏流程的,有针对任务流程的,有针对AI的,有针对技能的,有针对Buff的.</p><h2 id="节点的数据输入输出"><a href="#节点的数据输入输出" class="headerlink" title="节点的数据输入输出"></a>节点的数据输入输出</h2><p>额外的,每个节点都有可能有自己接受的输入和输出.针对这种需求,在具体的实现的类中,比如ActionNode中,增加一个string字段,标记是输出即可.后续由逻辑层来处理这个输出</p><p>任意节点的输出会在运行时放入blackboard中,同时,也可以从blackboard中获取其他节点输出的数据.</p><h2 id="行为树数据保存"><a href="#行为树数据保存" class="headerlink" title="行为树数据保存"></a>行为树数据保存</h2><p>对于客户端数据,我们使用ScriptableObject.</p><p>对于服务器数据</p><h1 id="逻辑层设计"><a href="#逻辑层设计" class="headerlink" title="逻辑层设计"></a>逻辑层设计</h1><p>上述基本的数据结构定义完毕之后,在ET中的运行方式,便是创建行为树的运行时的逻辑分发了.</p><p>针对行为树运行期间的环境,引入了一个特殊的实体Blackboard,它代表着一颗行为树运行期间的运行时环境,<br>运行完毕之后释放.它的生命周期就代表着行为树的生命周期.</p><p>举例,一个技能的释放逻辑是先播放施法动画,等待300ms后,创建火球<br>(火球带有AI,根据传入的目标参数飞行).这时候行为树的配置就是Spell根节点下添加一个序列节点,序列节点的子节点有Wait+CreateUnit:</p><ul><li><p>Spell (RootNode,技能根节点,代表这个是针对技能运行的行为树)</p><ul><li><p>Sequence</p><ul><li><p>Wait (等待300ms)</p></li><li><p>CreateUnit (创建火球)</p></li></ul></li></ul></li></ul><p>作为一个运行时环境,Blackboard最重要的一个功能就是接受和存储所有节点的输出数据.这些输出数据作为一个KV结构,存在Blackboard中:</p><h2 id="事件驱动的运行逻辑"><a href="#事件驱动的运行逻辑" class="headerlink" title="事件驱动的运行逻辑"></a>事件驱动的运行逻辑</h2><p>行为树的逻辑驱动使用事件驱动是性能最好,逻辑最清晰的选择.</p><p>以技能为例,一个技能的行为树在运行的时候,可能要接收和处理的事件类型大概有:</p><ul><li><p>Start</p></li><li><p>Interrupt (被打断)</p></li><li><p>End</p></li><li><p>Tick<br>(技能运行期间持续接收用户输入,比如LOL大眼的大招,或者老司机大招,跟随鼠标改变方向)</p></li></ul><p>如果是Buff,则可能有Add,Remove(被主动移除),Timeout(持续时间到了移除),OnUnitDie(Buff依附的角色死亡)等.</p><p>由此,行为树的运行逻辑中引入一个变量BTEventType.数据结构层面也增加一个特殊的组合节点<br>:</p><p>在编辑器上,可以添加不同的BTEventType下,行为树从哪个子节点开始执行的逻辑.</p><p>外部在运行一棵树时,可以从RootNode开始传入自己想要的BTEventType.这个参数会在整棵树的运行中向下传递.</p><ul><li><p>RootNode (可能是技能，任务，剧情，流程等)</p><ul><li><p>EventDispatchNode (比如SpellStart)</p><ul><li>Sequence</li></ul></li><li><p>EventDispatchNode (比如SpellTick)</p><ul><li>XXXX</li></ul></li></ul></li></ul><p>树每次运行的时候,都是上层传入一个特定的EventType.<br>然后从RootNode开始,找到匹配的EventDispatcherNode,往下执行,不匹配的就忽略.</p><p>可以把EventDispatcherNode看成一种分支.每次行为树的运行都是运行在一个分支上.</p><p>也就是RootNode的运行逻辑是遍历所有子物体,挨个执行,不管执行结果.</p><p>EventDispatcherNode的运行逻辑是检测EventType是否和自己的匹配,匹配就执行自己的子节点,不匹配就直接return</p><h1 id="逻辑层设计-节点逻辑可随时热更的问题"><a href="#逻辑层设计-节点逻辑可随时热更的问题" class="headerlink" title="逻辑层设计(节点逻辑可随时热更的问题)"></a>逻辑层设计(节点逻辑可随时热更的问题)</h1><p>使用ETTask的方式本质上创建了闭包,如果整棵树的运行逻辑,只有简单的等待一定时间(通常时间较短,比如3秒5秒10秒),那么这个行为树运行期间无法热更不是大问题.</p><p>但是如果在任务,游戏流程所使用的节点逻辑中出现了一些长时间的等待操作.比如等待用户输入,等待玩家打死指定怪物,等待副本通关等等,那么这个节点的逻辑在热更时就不起效了.</p><p>对这一点有顾虑的情况下,可以考虑去掉ETTask的实现,改为回调方式.即把之前长时间await前后的逻辑主动拆分为两个方法,如此一来,行为树的逻辑分发就被拆分为:</p><p>由外部在合适的情况下触发对应的逻辑,即可实现节点逻辑的随时热更.</p><p>(更具体的设计看是否有人有这个需求,再写出来)</p><p>但这样会带来一些代码书写的方便性上的问题.</p><p>生产中可以根据自己的需求来决定使用哪种方式.</p><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="编辑器设计"><a href="#编辑器设计" class="headerlink" title="编辑器设计"></a>编辑器设计</h1><p>编辑器需要实现的需求有：</p><ul><li><p>针对任务，剧情，流程，AI，技能，Buff等应用场景，每个场景都有专属的编辑器界面（如果不扩展那就使用默认的编辑器）即有对应的EditorWindow(整个游戏的所有类型的编辑器可以通过一个总编辑器打开，这个就交给使用者自行实现)</p></li><li><p>每个专属的编辑器界面都只能添加和使用通用节点和专属的节点。（比如剧情这边有一个Chat节点，任务这边一般是不能使用的）这一点可以通过对应节点的命名空间来实现（每个编辑器需要自定义节点的命名空间白名单，比如任务的只能使用ET.Common、ET.Quest下的节点）</p></li><li><p>节点平时缩略显示，支持以【MainField】之类的标签定义节点哪怕缩略显示时也要显示的数据，比如下图中的节点，默认只显示MainField标记的字段+备注信息，如果没有MainField字段，就显示一个名字（支持NodeName标签自定义名字显示，如果没有，再显示类名）+备注</p></li><li><p><img src="/media/image1.png" alt="descript">{width&#x3D;”2.855229658792651in”<br>height&#x3D;”2.40625in”}</p></li><li><p>节点的详细显示在点击节点的时候出现<br>（整个EditorWindow的右边）。还可以使用【NoInspector】标签加到节点上，让节点不需要详细显示，这对于如序列Sequence这样的特殊节点很有用。</p></li><li><p>特定节点的显示可以实现自定义的显示逻辑.配合NoInspector,就可以让如Sequence这样的节点只显示一个简单的箭头图标了</p></li><li><p>编辑器专用的数据和运行时分开。对于任意一颗行为树，编辑器也有一个Id相同的行为树数据，这份数据可以名字就是id，方便加载行为树的时候寻找。</p></li><li><p>编辑器的总体操作方式接近XNode。节点位置固定计算得出，一个节点的子节点，从上到下严格对应于List&lt;Node&gt;<br>Childs中的顺序。</p></li><li><p>节点可以折叠，折叠后触发位置重新计算，而且该节点的所有子节点都隐藏</p></li></ul><p>基于这样的原则,我们有如下设计:</p><h2 id="组件化界面IComponentDrawer"><a href="#组件化界面IComponentDrawer" class="headerlink" title="组件化界面IComponentDrawer"></a>组件化界面IComponentDrawer</h2><p>最好组件化方式做界面逻辑.因为行为树编辑器的界面后续需要新增很多东西,比如资源的选择界面,行为树的Debug信息.</p><p>比如设计一个IComponentDrawer,<br>每个IComponentDrawer都会持有对顶层BaseGraph的引用,并根据传入的Rect做渲染.</p><p>IComponentDrawer可以有通用的,所有需要的数据都在BaseGraph中定义.也可以有专用的,需要的数据在具体的Graph中定义.<br>(如果是专用的,需要在创建的时候检查引用的Graph是否正确)</p><p>顶层的Graph中存在Dict&lt;Type,IComponentDrawer&gt;,同时规划哪个区域渲染哪个IComponentDrawer.</p><p>IComponentDrawer之间可能存在联系,比如A区域选择某个数据,B区域这对这个数据做显示.这种逻辑就是依赖对应Graph中的数据即可.</p><p>IComponentDrawer根据需求,初步需要这么几个:</p><ul><li><p>节点编辑主区域(难度4星):<br>处理拖拽,缩放,节点之间的连线.Debug的时候,连线和节点可以发光来显示执行到哪了.</p></li><li><p>节点信息Inspector（难度1星）:<br>选中一个节点后出现的详细信息.可以考虑直接复用Odin的渲染.</p></li><li><p>Debug信息面板（难度2星）:<br>显示当前正在Debug的Entity.以及BlackBoard当中的数据(完全基于Json数据做处理，需要支持Json数组节点的展开收缩).如果使用者需要Debug服务器的blackboard数据，那么这个数据的获取可以通过协议实现（使用者自己解决，编辑器这里不做这个）</p></li><li><p>行为树资源文件管理器（难度2星）:<br>可以总览当前这个编辑器操作的这一类行为树资源,可以双击查看对应行为树,可以删除,可以复制行为树,可以新建.<br>(有多级文件夹,文件夹可以折叠)</p></li></ul><blockquote><p><img src="/media/image2.png" alt="descript">{width&#x3D;”3.3541666666666665in”<br>height&#x3D;”4.364583333333333in”}大概这种感觉.</p></blockquote><ul><li>(畅想一下,不需要实现) 时间轴编辑方式:</li></ul><blockquote><p><img src="/media/image3.png" alt="descript">{width&#x3D;”6.065972222222222in”<br>height&#x3D;”3.420974409448819in”}</p><p>(意思到位就好.<br>竖轴代表时间,竖轴上可以建立节点,节点对应一个时间值,这个节点可以创建一系列行为)</p></blockquote><p>节点的显示使用Odin,同时也支持自定义(节点显示的逻辑分发)</p><h1 id="编辑器布局和操作设计"><a href="#编辑器布局和操作设计" class="headerlink" title="编辑器布局和操作设计"></a>编辑器布局和操作设计</h1><p>节点之前的连线对应EditorNode的父子关系,而且连线不使用曲线,使用下图中的折线</p><p><img src="/media/image4.png" alt="descript">{width&#x3D;”4.239583333333333in”<br>height&#x3D;”3.5729166666666665in”}</p><p>节点的添加&#x2F;移除,改变顺序等操作,要支持Undo机制.<br>(可以基于Unity的Undo的API实现,也可以自己弄个栈实现)</p><p>支持特定快捷键:</p><ul><li><p>Ctrl+S 保存这棵树<br>(对应的Graph有自己的存储方法,调用即可,可以在BaseGraph抽个抽象方法,子类实现)</p></li><li><p>Del,当前有选中节点的话,删除这个节点.<br>如果这个节点拥有子节点,连它的子节点一起删除.(实际上EditorNode的Childs中移除就自然而然的做到了这一点)</p></li><li><p>Ctrl+Z : 回退操作<br>(刚才加了个子节点就删除,改变顺序就还原回来,删除节点就恢复回来)</p></li><li><p>Ctrl+R: 替换节点<br>(就是替换EditorNode中引用的NodeId),要注意类型匹配(比如一个组合节点只能替换为另一个组合节点,Action节点同理).根节点RootNode不允许替换.</p></li></ul><p>支持鼠标操作：</p><ul><li><p>可以像XNode那样，拖动一个子节点的上下位置，释放后可以改变它在父节点（一般是组合节点）下的顺序。</p></li><li><p>可以把A节点拖动到B节点身上，变成B节点的子节点（A的子节点是一起变过去的，不过只要把A原来的父子关系解除，嫁接到B身上，这个是自动的）</p></li><li><p>鼠标中键按住后，整个界面可以被拖拽（画布平移）</p></li><li><p>鼠标滚轮滑动时，整个界面可以被缩小放大</p></li></ul><h1 id="编辑器上的数据保存和加载"><a href="#编辑器上的数据保存和加载" class="headerlink" title="编辑器上的数据保存和加载"></a>编辑器上的数据保存和加载</h1><p>在编辑器打开期间,行为树本身的数据只是一个Dict&lt;id,Node&gt;.<br>用户所有的操作都是在针对EditorNode进行编辑和修改.</p><p>在保存时,根据保存的数据模型不同,创建不同的实例(比如客户端基于ScriptableObject的),然后遍历EditorNode,根据所有编辑器节点的父子关系,重新构建行为树Node之间的关系.之后保存数据即可.</p><p>在加载时,根据源文件加载出来的数据要DeepClone.<br>注意Clone的时候忽略掉Childs Child这种父子关系的字段.</p><p>(这个DeepClone可能要自己实现下,通过反射执行,如果是值类型,直接复制,如果是引用类型,复制引用即可.比如对特效,音效的引用.<br>如果加了DeepCloneIgnore标签,就忽略掉,比如Childs,Child字段)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大纲&quot;&gt;&lt;a href=&quot;#大纲&quot; class=&quot;headerlink&quot; title=&quot;大纲:&quot;&gt;&lt;/a&gt;大纲:&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;数据结构设计.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;逻辑层设计 (+节点热更问题)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编</summary>
      
    
    
    
    
  </entry>
  
</feed>
